#ifndef ossimJob_HEADER
#define ossimJob_HEADER
#include <ossim/base/ossimObject.h>
#include <OpenThreads/Mutex>
#include <OpenThreads/ScopedLock>
#include <ossim/base/ossimRefPtr.h>
#include <ossim/base/ossimString.h>
#include <list>

   class ossimJob;
   class OSSIM_DLL ossimJobCallback : public ossimReferenced
   {
   public:
      ossimJobCallback(ossimJobCallback* nextCallback=0):m_nextCallback(nextCallback){}
      virtual void ready(ossimJob* job){if(m_nextCallback.valid()) m_nextCallback->ready(job); }
      virtual void started(ossimJob* job){if(m_nextCallback.valid()) m_nextCallback->started(job); }
      virtual void finished(ossimJob* job){if(m_nextCallback.valid()) m_nextCallback->finished(job);}
      virtual void canceled(ossimJob* job){if(m_nextCallback.valid()) m_nextCallback->canceled(job);}
      
      virtual void nameChanged(const ossimString& name, ossimJob* job){if(m_nextCallback.valid()) m_nextCallback->nameChanged(name, job);}
      virtual void descriptionChanged(const ossimString& description, ossimJob* job){if(m_nextCallback.valid()) m_nextCallback->descriptionChanged(description, job);}
      virtual void idChanged(const ossimString& id, ossimJob* job){if(m_nextCallback.valid()) m_nextCallback->idChanged(id, job);}
      
      virtual void percentCompleteChanged(double percentValue, ossimJob* job){if(m_nextCallback.valid()) m_nextCallback->percentCompleteChanged(percentValue, job);}
      void setCallback(ossimJobCallback* c){m_nextCallback = c;}
   protected:
      ossimRefPtr<ossimJobCallback> m_nextCallback;
   };
   class OSSIM_DLL ossimJob : public ossimObject
   {
   public:
      typedef std::list<ossimRefPtr<ossimJob> > List;
      enum State
      {
         ossimJob_READY    = 0,
         ossimJob_RUNNING  = 1,
         ossimJob_CANCEL   = 2,
         ossimJob_FINISHED = 4,
         
      };
      virtual void start()=0;
      ossimJob()
      :m_state(ossimJob_READY),
      m_priority(0.0)
      {
      }
      
      void setPercentComplete(double value)
      {
         OpenThreads::ScopedLock<OpenThreads::Mutex> lock(m_jobMutex);
         if(m_callback.valid())
         {
            m_callback->percentCompleteChanged(value, this);
         }
      }
      void setPriority(double value)
      {
         OpenThreads::ScopedLock<OpenThreads::Mutex> lock(m_jobMutex);
         m_priority = value;
      }
      double priority()const
      {
         return m_priority;
      }
      virtual void release(){}
      State state()const
      {
         OpenThreads::ScopedLock<OpenThreads::Mutex> lock(m_jobMutex);
         return m_state;
      }
      virtual void setState(State value);
      bool isCanceled()const
      {
         OpenThreads::ScopedLock<OpenThreads::Mutex> lock(m_jobMutex);
         return (m_state == ossimJob_CANCEL);
      }
      virtual void cancel()
      {
         setState(ossimJob_CANCEL);
      }
      bool isReady()const
      {
         OpenThreads::ScopedLock<OpenThreads::Mutex> lock(m_jobMutex);
         return m_state == ossimJob_READY;
      }
      bool isStopped()const
      {
         OpenThreads::ScopedLock<OpenThreads::Mutex> lock(m_jobMutex);
         return ((m_state == ossimJob_CANCEL)||
                 (m_state == ossimJob_FINISHED));
      }
      
      void setCallback(ossimJobCallback* callback)
      {
         OpenThreads::ScopedLock<OpenThreads::Mutex> lock(m_jobMutex);
         m_callback = callback;
      }
      void setName(const ossimString& value)
      {
         bool changed = false;
         ossimRefPtr<ossimJobCallback> callback;
         {
            OpenThreads::ScopedLock<OpenThreads::Mutex> lock(m_jobMutex);
            changed = value!=m_name;
            m_name = value;
            callback = m_callback;
         }
         if(changed&&callback.valid())
         {
            callback->nameChanged(value, this);
         }
      }
      const ossimString& name()const
      {
         OpenThreads::ScopedLock<OpenThreads::Mutex> lock(m_jobMutex);
         return m_name;
      }
      void setId(const ossimString& value)
      {
         bool changed = false;
         ossimRefPtr<ossimJobCallback> callback;
         {
            OpenThreads::ScopedLock<OpenThreads::Mutex> lock(m_jobMutex);
            changed = value!=m_id;
            m_id = value;
            callback = m_callback;
         }
         if(changed&&callback.valid())
         {
            callback->idChanged(value, this);
         }
      }
      const ossimString& id()const
      {
         OpenThreads::ScopedLock<OpenThreads::Mutex> lock(m_jobMutex);
         return m_id;
      }
      void setDescription(const ossimString& value)
      {
         bool changed = false;
         ossimRefPtr<ossimJobCallback> callback;
         {
            OpenThreads::ScopedLock<OpenThreads::Mutex> lock(m_jobMutex);
            changed = value!=m_description;
            m_description = value;
            callback = m_callback;
         }
         if(changed&&callback.valid())
         {
            callback->descriptionChanged(value, this);
         }
      }
      const ossimString& description()const
      {
         OpenThreads::ScopedLock<OpenThreads::Mutex> lock(m_jobMutex);
         return m_description;
      }
      ossimJobCallback* callback(){return m_callback.get();}
   protected:
      mutable OpenThreads::Mutex m_jobMutex;
      ossimString m_name;
      ossimString m_description;
      ossimString m_id;
      State       m_state;
      double      m_priority;
      ossimRefPtr<ossimJobCallback> m_callback;
   };

#endif
